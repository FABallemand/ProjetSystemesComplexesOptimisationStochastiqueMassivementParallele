/*___________________________________________________________________

	find_newton.ez // Loi de la Gravitation Universelle de Newton
___________________________________________________________________*/

\User declarations :
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <float.h>

static constexpr double max_init_value = 1.0E31; //< Maximum value for random initialisation
static constexpr double proba_mut = 0.2;		 //< Probabilty of mutation
static constexpr double var_mut = 0.05;			 //< Taux de variation lors de la mutation

// Constants
#define NB_SAMP 1024
#define DIM 2
#define R 0
#define THETA 1

static constexpr double sun_mass = 1.9884E30;			           //< Sun mass (kg)
static constexpr double earth_mass = 1.9884E30;					   //< Sun mass (kg)
static constexpr double g_const = 6.67408E-11;					   //< Gravitational constant
static constexpr double delta_t = (365.25 * 24 * 3600) / NB_SAMP;  //< Duration between two steps

// Variables
static double trajectory[NB_SAMP][DIM]; //< Earth trajectory around Sun (polar coord.)
static double prev_speed[DIM];			//< Speed at previous step (polar coord.)
static double curr_speed[DIM];			//< Speed at current step (polar coord.)
static int n = 0;						//< Current step
\end

\User functions :
\end

\User CUDA :
\end

\Before everything else function :
srand(time(NULL)); // Initialise seed

// Initial conditions
trajectory[n][R] = 147.1E9;						      // Initial position (perihelion)
trajectory[n][THETA] = M_PI;						  // Initial position (perihelion)
curr_speed[R] = 0;									  // Initial speed (perihelion)
curr_speed[THETA] = (2 * M_PI) / (365.5 * 24 * 3600); // Initial speed (average)
n++;												  // Next step
// Compute trajectory
for (; n < NB_SAMP; n++)
{
	prev_speed[R] = curr_speed[R];
	prev_speed[THETA] = curr_speed[THETA];

	curr_speed[R] = prev_speed[R] + (trajectory[n - 1][R] * prev_speed[THETA] * prev_speed[THETA] - ((g_const * sun_mass) / (trajectory[n - 1][R] * trajectory[n - 1][R]))) * delta_t;
	curr_speed[THETA] = prev_speed[THETA] + ((-2 * prev_speed[R] * prev_speed[THETA]) / trajectory[n - 1][R]) * delta_t;

	trajectory[n][R] = trajectory[n - 1][R] + curr_speed[R] * delta_t;
	trajectory[n][THETA] = trajectory[n - 1][THETA] + curr_speed[THETA] * delta_t;
}
\end

\After everything else function :
\end

\At the beginning of each generation function :
\end

\At each generation before reduce function :
\end

\At the end of each generation function :
\end

\User classes : GenomeClass
{
  double sun_mass_to_find;
}
\end

\GenomeClass::display :
\end

\GenomeClass::initialiser :
// Genome.sun_mass_to_find = ((double)rand() / (double)(RAND_MAX)) * max_init_value;
Genome.sun_mass_to_find = random(1.0, 1.0E31);

printf("==== INITIALISER =================================================\n");
printf("SUN MASS: %f (init)\n", Genome.sun_mass_to_find);
printf("==================================================================\n");
\end

\GenomeClass::crossover : // by default when entering the function child is a clone of parent1
	child.sun_mass_to_find = (child.sun_mass_to_find + parent2.sun_mass_to_find) / 2;
\end

\GenomeClass::mutator :
if (tossCoin(proba_mut))
{
  if (tossCoin(0.5))
  {
	  Genome.sun_mass_to_find += Genome.sun_mass_to_find * var_mut;
  }
  else
  {
	  Genome.sun_mass_to_find -= Genome.sun_mass_to_find * var_mut;
  }
}
\end

\GenomeClass::evaluator : // Lower is better
// Variables
double trajectory_estimated[NB_SAMP][DIM]; //< Earth trajectory around Sun (polar coord.)
double prev_speed_estimated[DIM];		  //< Speed at previous step (polar coord.)
double curr_speed_estimated[DIM];		  //< Speed at current step (polar coord.)
int n_estimated = 0;					  //< Current step

// Initial conditions
trajectory_estimated[n_estimated][R] = 147.1E9;					// Initial position (perihelion)
trajectory_estimated[n_estimated][THETA] = M_PI;				// Initial position (perihelion)
curr_speed_estimated[R] = 0;									// Initial speed (perihelion)
curr_speed_estimated[THETA] = (2 * M_PI) / (365.5 * 24 * 3600); // Initial speed (average)
n_estimated++;													// Next step

// Compute trajectory
for (; n_estimated < NB_SAMP; n_estimated++)
{
  prev_speed_estimated[R] = curr_speed_estimated[R];
  prev_speed_estimated[THETA] = curr_speed_estimated[THETA];

  curr_speed_estimated[R] = prev_speed_estimated[R] + (trajectory_estimated[n_estimated - 1][R] * prev_speed_estimated[THETA] * prev_speed_estimated[THETA] - ((g_const * Genome.sun_mass_to_find) / (trajectory_estimated[n_estimated - 1][R] * trajectory_estimated[n_estimated - 1][R]))) * delta_t;
  curr_speed_estimated[THETA] = prev_speed_estimated[THETA] + ((-2 * prev_speed_estimated[R] * prev_speed_estimated[THETA]) / trajectory_estimated[n_estimated - 1][R]) * delta_t;

  trajectory_estimated[n_estimated][R] = trajectory_estimated[n_estimated - 1][R] + curr_speed_estimated[R] * delta_t;
  trajectory_estimated[n_estimated][THETA] = trajectory_estimated[n_estimated - 1][THETA] + curr_speed_estimated[THETA] * delta_t;
}

double score = 0.0;
double x, y, x_estimated, y_estimated;
for (int i = 0; i < 1024; i++)
{
	x = trajectory[i][R] * cos(trajectory[i][THETA]);
	y = trajectory[i][R] * sin(trajectory[i][THETA]);
	x_estimated = trajectory_estimated[i][R] * cos(trajectory_estimated[i][THETA]);
	y_estimated = trajectory_estimated[i][R] * sin(trajectory_estimated[i][THETA]);
	// printf("%d -> %f,%f | %f,%f\n", i, x, y, x_estimated, y_estimated);
	score += sqrt((x - x_estimated)*(x - x_estimated) + (y - y_estimated)*(y - y_estimated));
}
if (score != score)
{
	score = DBL_MAX - 1;
}

printf("SUN MASS: %f (real), %f (estimated), [%f]\n", sun_mass, Genome.sun_mass_to_find, sun_mass / Genome.sun_mass_to_find);
printf("SCORE: %f\n", score);
printf("==================================================================\n");
return score;
\end

\User Makefile options :
\end

\Default run parameters :
Number of generations : 60   			// NB_GEN
Time limit : 0              			// In seconds, 0 to deactivate
Population size : 100    	 			// POP_SIZE
Offspring size : 100%        			// (percentage or absolute) 40% of the population size or 40
Crossover probability : 1   			// XOVER_PROB (0.8 -> 20% of children are just clones of parent)
Mutation probability : 1    			// MUT_PROB (???)
Evaluator goal : minimise  	 			// Goal of the operation (maximise/minimise)
Selection operator: Tournament 2		// (Tournament returns the best out of the [arg] individuals)
Surviving parents : 100 % 		 		// Preselection of parents for the next generation (percentage or absolute)
Surviving offspring : 100 %  	 		// Preselection of children for the next generation (percentage or absolute)
Reduce parents operator: Tournament 2 	// How the preselection in done
Reduce offspring operator: Tournament 2 // How the preselection in done
Final reduce operator: Tournament 2 	// To determine who will be part of gen+1

Elitism : Weak // Weak (keep the "elite" best PARENTS+CHILDREN into the next generation) or Strong (keep the "elite" best PARENTS)
Elite : 1 
Print stats : true // Sho evolution, Default: true
Generate csv stats file : false
Generate gnuplot script : false
Generate R script : false
Plot stats : true // Default: true

Remote island model : false // Paralellism
IP file : ip.txt 			// File containing all the remote island's IP
Server port : 2929
Migration probability : 0.3

Save population : false
Start from file : false
\end

/*
//======================//
// HOW TO RUN THIS FILE //
//======================//

1/ Go to https://easea.unistra.fr/index.php/Installing_EASEA and install easea

2/ Compile with easena: easena find_newton.ez

3/ Compile all C/C++/CUDA files: make

*/